# 一、数据的二级制

计算机中所有的内容：文字、数字、图片、音频、视频最终都会使用二进制来表示。

JavaScript 可以直接去处理非常直观的数据：比如字符串，我们通常展示给用户的也是这些内容。

不对啊，JavaScript不是也可以处理图片吗？
- 事实上在网页端，图片我们一直是交给浏览器来处理的；
- JavaScript或者HTML，只是负责告诉浏览器一个图片的地址；
- 浏览器负责获取这个图片，并且最终讲这个图片渲染出来；

但是对于服务器来说是不一样的：
- 服务器要处理的本地文件类型相对较多;
- 比如某一个保存文本的文件并不是使用 utf-8进行编码的，而是用 GBK（早期 Windows 用），那么我们必须读取到他们的二进制数据，再通过GKB转换成 对应的文字；
- 比如我们需要读取的是一张图片数据（二进制），再通过某些手段对图片数据进行二次的处理（裁剪、格式转换、旋转、添加滤镜）， Node中有一个Sharp的库，就是读取图片或者传入图片的Buffer对其再进行处理；
- 比如在Node中通过TCP建立长连接，TCP传输的是字节流，我们需要将数据转成字节再进行传入，并且需要知道传输字节的大小（客服端需要根据大小来判断读取多少内容）；

---

# 二、Buffer 和二进制关系

我们会发现，对于前端开发来说，通常很少会和二进制直接打交道，但是对于服务器端为了做很多的功能，我们必须直接去操作 其二进制的数据；

所以Node为了可以方便开发者完成更多功能，提供给了我们一个类Buffer，并且它是全局的。

我们前面说过，Buffer中存储的是二进制数据，那么到底是如何存储呢？
- 我们可以将Buffer看成是一个存储二进制的数组；
- 这个数组中的每一项，可以保存8位二进制： 0000 0000（一个字节）
  - 表示一个 1，不会仅仅是一个 1，而是以 0000 0001 来表示。
  - rgb(255, 255, 255)
    - r 一个字节 1111 1111 => 0 ~ 255

为什么是8位呢？
- 在计算机中，很少的情况我们会直接操作一位二进制，因为一位二进制存储的数据是非常有限的；
- 所以通常会将8位合在一起作为一个单元，这个单元称之为一个字节（byte）；
- 也就是说 1byte = 8bit，1kb=1024byte，1M=1024kb；
- 比如很多编程语言中的int类型是4个字节，long类型时8个字节；
- 比如TCP传输的是字节流，在写入和读取时都需要说明字节的个数；
- 比如RGB的值分别都是255，所以本质上在计算机中都是用一个字节存储的；

buffer 的一位，就是一个字节。一个 255；

能表示最大的数字是 255

能表示最多的数字是 256 个数字，因为还包括一个 0；

buffer 的三种表示方式

- 一个字节
- [1111 1111]
- [ff]（换算成十六进制表示，本质上还是二进制）

---

# 三、Buffer 和字符串转化

Buffer相当于是一个字节的数组，数组中的每一项对应一个字节的大小：

如果我们希望将一个字符串放入到Buffer中，是怎么样的过程呢？

它是怎么样的过程呢？



用 buffer 存储一个字符串。

1. 字符串编码。
2. 编码后保存为二进制。
3. 存储进 buffer。



如果是中文呢？

中文通常用 3 个字节，复杂的中文汉字，通常使用 4 个字节。

默认编码：utf-8

- 比如用 buffer.toString ，默认会用 utf8 编码将 buffer 转成字符串。
- tf8 编码中，包含了 Ascll 编码。

如果编码和解码不同：

---

# 四、Buffer 的其它用法

Buffer.alloc

Buffer 文件读取。

- 读取文本。
- 读取图片。将读取的文件，放在 buffer 中，对 buffer 进行操作，再写入到图片文件中。这样就能通过 buffer 对图片等等（二进制文件）进行操作。

---

# 五、Buffer 部分源码分析

Buffer 的创建过程理解。

Buffer.form 源码。

fromString 源码。

fromStringFast 源码。

---

# 六、什么是 Stream

什么是Stream（小溪、小河，在编程中通常翻译为流）呢？
- 我们的第一反应应该是流水，源源不断的流动；
- 程序中的流也是类似的含义，我们可以想象当我们从一个文件中读取数据时，文件的二进制（字节）数据会源源不断的被读 取到我们程序中；
- 而这个一连串的字节，就是我们程序中的流；

所以，我们可以这样理解流：
- 是连续字节的一种表现形式和抽象概念；
- 流应该是可读的，也是可写的；

在之前学习文件的读写时，我们可以直接通过 readFile或者 writeFile方式读写文件，为什么还需要流呢？
- 直接读写文件的方式，虽然简单，但是无法控制一些细节的操作；
- 比如从什么位置开始读、读到什么位置、一次性读取多少个字节；
- 读到某个位置后，暂停读取，某个时刻恢复继续读取等等；
- 或者这个文件非常大，比如一个视频文件，一次性全部读取并不合适；

---

# 七、文件读写的流

事实上Node中很多对象是基于流实现的：
- http模块的Request和Response对象；

官方文档：另外所有的流都是EventEmitter的实例。

那么在Node中都有哪些流呢？

Node.js中有四种基本流类型：
- Writable：可以向其写入数据的流（例如 fs.createWriteStream()）。
- Readable：可以从中读取数据的流（例如 fs.createReadStream()）。
- Duplex：同时为Readable和Writable（例如 net.Socket）。
- Transform：Duplex可以在写入和读取数据时修改或转换数据的流（例如zlib.createDeflate()）用于压缩。


这里我们通过fs的操作，讲解一下Writable、Readable，另外两个大家可以自行学习一下。

---

# 八、Readable 可读流

之前我们读取一个文件的信息：

这种方式是一次性将一个文件中所有的内容都读取到程序（内存）中，但是这种读取方式就会出现我们之前提到的很多问题：
- 文件过大、读取的位置、结束的位置、一次读取的大小；

这个时候，我们可以使用 createReadStream，我们来看几个参数，更多参数可以参考官网：
- start：文件读取开始的位置；
- end：文件读取结束的位置（包括，闭区间）；
- highWaterMark：一次性读取字节的长度，默认是64kb；